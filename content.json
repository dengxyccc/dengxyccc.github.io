{"meta":{"title":"邓晓煜的个人博客","subtitle":"行动是治愈恐惧的良药，而犹豫拖延将不断滋养恐惧","description":null,"author":"邓晓煜","url":"https://www.dengxy.cn","root":"/"},"pages":[{"title":"","date":"2021-03-17T07:04:52.537Z","updated":"2021-03-17T07:04:52.537Z","comments":true,"path":"about/index.html","permalink":"https://www.dengxy.cn/about/index.html","excerpt":"","text":""},{"title":"","date":"2021-03-17T07:00:59.628Z","updated":"2021-03-17T07:00:59.628Z","comments":false,"path":"tags/index.html","permalink":"https://www.dengxy.cn/tags/index.html","excerpt":"","text":""},{"title":"","date":"2021-03-17T07:04:56.764Z","updated":"2021-03-17T07:04:56.764Z","comments":false,"path":"categories/index.html","permalink":"https://www.dengxy.cn/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"JavaScript基本数据类型和引用数据类型","slug":"JavaScript基本数据类型和引用数据类型","date":"2021-03-30T08:11:31.000Z","updated":"2021-03-30T08:20:28.018Z","comments":true,"path":"2021/03/30/JavaScript基本数据类型和引用数据类型/","link":"","permalink":"https://www.dengxy.cn/2021/03/30/JavaScript%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"基本数据类型 基本类型值指的是简单的数据段，其中基本数据类型是直接保存在栈内存中，对于基本数据类型的传递则是进行值传递 Undifined Null Boolean Number String Symbol 引用数据类型 引用数据类型统称为 Object 类型，和基本数据类型不同的是引用数据类型在进行变量赋值的时候实际上传递的是引用地址，在栈内存中保存的是地址，在堆内存中保存着地址对应的值 Object Array Date RegExp Function 检测数据类型 JavaScript 是一种弱类型或者说动态语言。这意味着你不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。这也意味着你可以使用同一个变量保存不同类型的数据，那么如何进行数据类型检测确定，那么就要进行检测判断 typeof instanceof typeof 操作符的唯一目的就是检查数据类型，如果我们希望检查任何从 Object 派生出来的结构类型，使用 typeof 是不起作用的，因为总是会得到 “object”。检查 Object 种类的合适方式是使用 instanceof 关键字。但即使这样也存在误差。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.dengxy.cn/tags/JavaScript/"}]},{"title":"ArrayList的基本实现","slug":"ArrayList的基本实现","date":"2021-03-17T08:21:31.000Z","updated":"2021-03-18T09:09:10.435Z","comments":true,"path":"2021/03/17/ArrayList的基本实现/","link":"","permalink":"https://www.dengxy.cn/2021/03/17/ArrayList%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"ArrayList的基本实现1、通过Object类型的数组来实现，所以数组中需要存储基本类型数据的时候需要使用包装类 1234567891011121314151617181920212223242526272829public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable{ private static final long serialVersionUID = 8683452581122892189L; /** * Default initial capacity. */ private static final int DEFAULT_CAPACITY = 10; /** * Shared empty array instance used for empty instances. */ private static final Object[] EMPTY_ELEMENTDATA = {}; /** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. */ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; /** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. */ transient Object[] elementData; // non-private to simplify nested class access 2、初始化的无参构造函数为一个空对象数组，在添加第一个元素的时候，会默认申请10个大小的内存空间，如果添加到了尾端，在进行1.5倍的空间申请并将原来存储的数据挪动复制到新申请的内存空间中 123456/** * Constructs an empty list with an initial capacity of ten. */public ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;} 1234567891011121314151617/** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);} 3、数组在遍历的时候很快就是因为内存地址是连续的，所以查找某个位置的元素可以瞬间获取到，所以遍历的是特别快的，通过第一个元素的地址就能计算出后面第N位的元素地址 4、ArrayList实现了一个叫RandomAccess的空接口，实际上实现这个接口只是为了做打标，就是告诉别人当前的这个类支持快速访问，所以在进行泛型对象的遍历的时候，由于我们不清楚具体的实现类是什么，所以可以判断是否实现了RandomAccess接口，如果实现了此接口则进行for循环遍历集合，否之则使用迭代器，所以这里的RandomAccess就是为了告诉别人当前实现类支持快速访问，但实际上是否能快速访问还是因为存储的数据结构不一样 12345678910111213141516171819202122232425public static void loop(java.util.List list){ if(list instanceof RandomAccess) { // for循环 System.out.println(\"采用for循环遍历\"); for (int i = 0;i&lt; list.size();i++) { System.out.println(list.get(i)); } } else { // 迭代器 System.out.println(\"采用迭代器遍历\"); Iterator it = list.iterator(); while(it.hasNext()){ System.out.println(it.next()); } }}public static void main(String[] args) { java.util.List&lt;String&gt; list = Arrays.asList(\"123\",\"456\",\"789\",\"1110\"); java.util.List&lt;String&gt; list1 = new LinkedList&lt;&gt;(); list1.add(\"aaa\"); list1.add(\"bbb\"); list1.add(\"ccc\"); loop(list); loop(list1);} 5、ArrayList中的存储数组elementData是用transient修饰的，而ArrayList又是实现了Serializable接口表明是可实例化的，这里就是很矛盾，因为被transient修饰的数据是不会被实例化的。实际上是因为刚刚说的数组的空间是必须要提前申请的，所以这里有个问题就是数组可能会空间比较大，但实际上存储的元素没有那么多。所以在序列化的时候完全不需要去序列化那些空内存，所以ArrayList手动实现了序列化方法，根据元素的多少进行序列化。 1234567/** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. */transient Object[] elementData; // non-private to simplify nested class access 1234567891011121314151617181920212223242526/** * Save the state of the &lt;tt&gt;ArrayList&lt;/tt&gt; instance to a stream (that * is, serialize it). * * @serialData The length of the array backing the &lt;tt&gt;ArrayList&lt;/tt&gt; * instance is emitted (int), followed by all of its elements * (each an &lt;tt&gt;Object&lt;/tt&gt;) in the proper order. */private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException{ // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i=0; i&lt;size; i++) { s.writeObject(elementData[i]); } if (modCount != expectedModCount) { throw new ConcurrentModificationException(); }} 12345678910111213141516171819202122232425/** * Reconstitute the &lt;tt&gt;ArrayList&lt;/tt&gt; instance from a stream (that is, * deserialize it). */private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { elementData = EMPTY_ELEMENTDATA; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in capacity s.readInt(); // ignored if (size &gt; 0) { // be like clone(), allocate array based upon size not capacity ensureCapacityInternal(size); Object[] a = elementData; // Read in all elements in the proper order. for (int i=0; i&lt;size; i++) { a[i] = s.readObject(); } }}","categories":[],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://www.dengxy.cn/tags/JAVA/"}]}],"categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.dengxy.cn/tags/JavaScript/"},{"name":"JAVA","slug":"JAVA","permalink":"https://www.dengxy.cn/tags/JAVA/"}]}